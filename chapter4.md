## 컴포지션이란?

한 클래스가 다른 클래스를 포함하고 있는 경우를 말합니다.

아래 코드에서 Car 클래스는 Engin 클래스 타입의 맴버변수를 가짐으로서 Engin 은 Car의 컴포지션으로 볼 수 있습니다.

```
public class Car {
int price;
Engin engin;
String color;

    public Car(int price, Engin engin, String color) {
        this.price = price;
        this.engin = engin;
        this.color = color;
    }
}
```

## 컴포지션 보다 상속을 써야하는 이유

보통 상속으로 구현한 부분은 컴포지션으로도 구현이 가능하고 반대로 상속으로 구현한부분은 컴포지션으로도 구현 가능 하다. 그러나 객체 지향적 설계시 상속 보다는 컴포지션을 권장한다. 그 이유는 다음과 같다.

1. 상위 클래스 변경의 어려움
    - 상속관계가 깊어질 수록 하위 클래스의 변경에 의해 상위 클래스를 변경이 어려워 진다.

2. 다중 상속의 불가
    - 상속을 통한 구현시 다중 상속이 불가하므로 필요한 기능을 제공하는 클래스가 존재하더라도 이미 한 클래스를 상속했다면 해당 기능은 따로 구현해야한다.


3. 상속의 오용
    - is-a 관계가 아닌 경우
    - 개발자가 의도치 않은 부모 클래스의 기능을 사용하므로써 잘못된 접근이 이루어 질 수 있음

위와 같은 문제는 모두 컴포지션을 통해 해결 될 수 있다. 추가적으로 컴포지션을 통한 구현시 런타임중 컴포지션 객체를 교체할 수 있는 장점이 있다.

## 위임

- 위임은 내가 할 일을 다른 객체에게 넘긴다는 의미를 갖는다. 컴포지션을 통해 위임을 구현할 수 있다.

A 클래스에서 B를 컴포지션으로 들고 있는 상황에서 C 기능을 제공하려할때 C 기능을 B가 이미 제공하고 있다면 따로 구현하지 않고 B를 통해 C 기능을 제공한다.

```
class A {
    val b = B()

    fun printWeather() {
        b.printWeather()
    }
}

class B() {
    fun printWeather() {
        //printingWeather
    }
}

```

- 컴포지션과 같이 맴버로 들고 있지 않더라도 위임을 구현 할 수도 있다.

```
class A {
    fun printWeather() {
        B().printWeather()
    }
}

class B() {
    fun printWeather() {
        //printingWeather
    }
}
```

## 추가적인 상속과 컴포지션의 선택 기준

### 1. 기준1 
   
has-a / is -a 일반적으로 컴포지션 과 상속을 결정하는 가장 보편적인 기준으로서
두 클래스가 has-a 관계일때는 컴포지션으로
반대로 is - a 관계일때는 상속으로 구현합니다. 

### 기준2 : 기계적(메모리) 이유
 아래 두가지  방법으로 box 를 생성했습니다. 두 방법에 대한 메모리 블럭을 그려보면 첫번째 box 변수는 힙 안에 [10,20,30]을 가리키고 있을 것입니다. 그리고 두번째 box 변수는 [rectangle의 주소값 , 30]을 들고 있고 rectangle 의 주소값은 다시 [10,20]을 가리키고 있을것입니다.
이에 기반해서 생각해보면 상속형 변수는 메모리에서 데이터를 한번에 가져올 수 있지만 컴포지션형 변수는 두번가져오게 되어 성능상 불이익이 발생할 수 있다.


```
// 상속
Box box = new Box(10,20,30)

// 컴포지션
Rectanle rectangle = new Ranctangle(10,20)
Box box = new Box(rectangle , 30)
```

### 기준3 : 용도의 차이
다형성을 필히 사용해야 하는 경우 상속을 선택해야합니다.



``